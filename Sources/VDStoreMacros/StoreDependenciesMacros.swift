#if canImport(SwiftCompilerPlugin)
import SwiftDiagnostics
import SwiftSyntax
import SwiftSyntaxMacros

public struct StoreDIValueMacro: AccessorMacro {

	public static func expansion(
		of node: AttributeSyntax,
		providingAccessorsOf declaration: some DeclSyntaxProtocol,
		in context: some MacroExpansionContext
	) throws -> [AccessorDeclSyntax] {

		// Skip declarations other than variables
		guard let varDecl = declaration.as(VariableDeclSyntax.self) else {
			throw CustomError("@StoreDIValue only works on variables")
		}

		guard var binding = varDecl.bindings.first?.as(PatternBindingSyntax.self) else {
			throw CustomError("No annotation provided.")
		}

		guard let identifier = binding.pattern.as(IdentifierPatternSyntax.self)?.identifier.text else {
			throw CustomError("Identifier is not valid.")
		}

		binding.pattern = PatternSyntax(IdentifierPatternSyntax(identifier: .identifier("defaultValue")))

		let isOptionalType = binding.typeAnnotation?.type.is(OptionalTypeSyntax.self) ?? false
		let hasDefaultValue = binding.initializer != nil

		guard isOptionalType || hasDefaultValue else {
			throw CustomError("No default value provided.")
		}

		let defaultValue = binding.initializer?.value.trimmed.description ?? "nil"

		return [
			"""
			get { get(\\.\(raw: identifier), or: \(raw: defaultValue)) }
			""",
			"""
			set {  set(\\.\(raw: identifier), newValue) }
			""",
		]
	}
}

public struct StoreDIValuesMacro: MemberAttributeMacro {

	public static func expansion(
		of node: AttributeSyntax,
		attachedTo declaration: some DeclGroupSyntax,
		providingAttributesFor member: some DeclSyntaxProtocol,
		in context: some MacroExpansionContext
	) throws -> [AttributeSyntax] {

		// Only attach macro if member is a variable.
		// Otherwise, it will also get attached to the structs generated by @EnvironmentValue
		guard member.is(VariableDeclSyntax.self) else {
			return []
		}

		return ["@StoreDIValue"]
	}
}
#endif

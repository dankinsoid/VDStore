import Foundation

public extension StoreDIValues {

	/// Returns the storage of async tasks. Allows to store and cancel tasks.
	var tasksStorage: TasksStorage {
		get { get(\.tasksStorage, or: .shared) }
		set { set(\.tasksStorage, newValue) }
	}
}

/// The storage of async tasks. Allows to store and cancel tasks.
public final class TasksStorage {

	/// The shared instance of the storage.
	public static let shared = TasksStorage()
	private let lock = NSRecursiveLock()

	private var tasks: [AnyHashable: [UUID: CancellableTask]] = [:]

	var count: Int { tasks.count }

	public init() {}

	/// Cancel a task by its cancellation id.
	public func cancel(id: AnyHashable) {
		lock.lock()
		tasks[id]?.forEach { $0.value.cancel() }
		tasks[id] = nil
		lock.unlock()
	}

	fileprivate func add<T, E: Error>(for id: AnyHashable, _ task: Task<T, E>, cancelInFlight: Bool) {
		if cancelInFlight {
			cancel(id: id)
		}
		let uuid = UUID()
		Task { [self] in
			addTask(task, id: id, uuid: uuid)
			defer {
				remove(id: id, uuid: uuid)
			}
			_ = try await task.value
		}
	}

	private func addTask<T, E: Error>(_ task: Task<T, E>, id: AnyHashable, uuid: UUID) {
		lock.lock()
		tasks[id, default: [:]][uuid] = task
		lock.unlock()
	}

	private func remove(id: AnyHashable, uuid: UUID) {
		lock.lock()
		tasks[id]?[uuid] = nil
		if tasks[id]?.isEmpty == true {
			tasks[id] = nil
		}
		lock.unlock()
	}
}

private protocol CancellableTask {

	func cancel()
}

extension Task: CancellableTask {}

public extension Store {

	/// Create a throwing task with cancellation id.
	/// - Parameters:
	///   - id: The task's identifier.
	///   - cancelInFlight: Determines if any in-flight tasks with the same identifier should be
	///     canceled before starting this new one.
	///   - task: The async throwing task.
	@discardableResult
	func task<T>(
		id: AnyHashable,
		cancelInFlight: Bool = false,
		_ task: @MainActor @escaping @Sendable () async throws -> T
	) -> Task<T, Error> {
		withDIValues {
			Task(operation: task)
				.store(in: di.tasksStorage, id: id, cancelInFlight: cancelInFlight)
		}
	}

	/// Create a task with cancellation id.
	/// - Parameters:
	///   - id: The task's identifier.
	///   - cancelInFlight: Determines if any in-flight tasks with the same identifier should be canceled before starting this new one.
	///   - task: The async task.
	@discardableResult
	func task<T>(
		id: AnyHashable,
		cancelInFlight: Bool = false,
		_ task: @MainActor @escaping @Sendable () async -> T
	) -> Task<T, Never> {
		withDIValues {
			Task(operation: task)
				.store(in: di.tasksStorage, id: id, cancelInFlight: cancelInFlight)
		}
	}

	/// Cancel an async store action.
	/// Action is a static property generated by `@Actions` macro for each method.
	func cancel<Arg, Res>(_ action: Action<Arg, Res>.Async) {
		cancel(id: action.id)
	}

	/// Cancel an async throwing store action.
	/// Action is a static property generated by `@Actions` macro for each method.
	func cancel<Arg, Res>(_ action: Action<Arg, Res>.AsyncThrows) {
		cancel(id: action.id)
	}

	/// Cancel a task by its cancellation id.
	func cancel(id: AnyHashable) {
		di.tasksStorage.cancel(id: id)
	}
}

public extension Task {

	/// Store the task in the storage by it cancellation id.
	/// - Parameters:
	///   - id: The task's identifier.
	///   - cancelInFlight: Determines if any in-flight tasks with the same identifier should be
	///     canceled before starting this new one.
	@MainActor
	@discardableResult
	func store(in storage: TasksStorage, id: AnyHashable, cancelInFlight: Bool = false) -> Task {
		storage.add(for: id, self, cancelInFlight: cancelInFlight)
		return self
	}
}
